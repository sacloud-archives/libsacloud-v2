// generated by 'github.com/sacloud/libsacloud/internal/tools/gen-api-op'; DO NOT EDIT

package sacloud

import (
	"context"
	"encoding/json"

	"github.com/sacloud/libsacloud-v2/pkg/mapconv"
	"github.com/sacloud/libsacloud-v2/sacloud/types"
)

func init() {

	SetClientFactoryFunc("Archive", func(caller APICaller) interface{} {
		return &ArchiveOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "archive",
		}
	})

	SetClientFactoryFunc("CDROM", func(caller APICaller) interface{} {
		return &CDROMOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "cdrom",
		}
	})

	SetClientFactoryFunc("Disk", func(caller APICaller) interface{} {
		return &DiskOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "disk",
		}
	})

	SetClientFactoryFunc("GSLB", func(caller APICaller) interface{} {
		return &GSLBOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "commonserviceitem",
		}
	})

	SetClientFactoryFunc("Interface", func(caller APICaller) interface{} {
		return &InterfaceOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "interface",
		}
	})

	SetClientFactoryFunc("LoadBalancer", func(caller APICaller) interface{} {
		return &LoadBalancerOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "appliance",
		}
	})

	SetClientFactoryFunc("NFS", func(caller APICaller) interface{} {
		return &NFSOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "appliance",
		}
	})

	SetClientFactoryFunc("Note", func(caller APICaller) interface{} {
		return &NoteOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "note",
		}
	})

	SetClientFactoryFunc("Server", func(caller APICaller) interface{} {
		return &ServerOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "server",
		}
	})

	SetClientFactoryFunc("Switch", func(caller APICaller) interface{} {
		return &SwitchOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "switch",
		}
	})

	SetClientFactoryFunc("Zone", func(caller APICaller) interface{} {
		return &ZoneOp{
			Client:     caller,
			PathSuffix: "api/cloud/1.1",
			PathName:   "zone",
		}
	})
}

/*************************************************
* ArchiveOp
*************************************************/

// ArchiveOp implements ArchiveAPI interface
type ArchiveOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewArchiveOp creates new ArchiveOp instance
func NewArchiveOp(caller APICaller) ArchiveAPI {
	return GetClientFactoryFunc("Archive")(caller).(ArchiveAPI)
}

// Find is API call
func (o *ArchiveOp) Find(ctx context.Context, zone string, conditions *FindCondition) ([]*Archive, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if conditions == nil {
			conditions = &FindCondition{}
		}
		if body == nil {
			body = &archiveFindRequestEnvelope{}
		}
		v := body.(*archiveFindRequestEnvelope)
		if err := mapconv.ConvertTo(conditions, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &archiveFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	var payload0 []*Archive
	for _, v := range nakedResponse.Archives {
		payload := &Archive{}
		if err := payload.convertFrom(v); err != nil {
			return nil, err
		}
		payload0 = append(payload0, payload)
	}
	return payload0, nil
}

// Create is API call
func (o *ArchiveOp) Create(ctx context.Context, zone string, param *ArchiveCreateRequest) (*Archive, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &ArchiveCreateRequest{}
		}
		if body == nil {
			body = &archiveCreateRequestEnvelope{}
		}
		v := body.(*archiveCreateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, err
		}
		v.Archive = n
		body = v
	}

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &archiveCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Archive{}
	if err := payload0.convertFrom(nakedResponse.Archive); err != nil {
		return nil, err
	}
	return payload0, nil
}

// CreateBlank is API call
func (o *ArchiveOp) CreateBlank(ctx context.Context, zone string, param *ArchiveCreateBlankRequest) (*Archive, *FTPServer, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &ArchiveCreateBlankRequest{}
		}
		if body == nil {
			body = &archiveCreateBlankRequestEnvelope{}
		}
		v := body.(*archiveCreateBlankRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, nil, err
		}
		v.Archive = n
		body = v
	}

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, nil, err
	}

	nakedResponse := &archiveCreateBlankResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, nil, err
	}

	payload0 := &Archive{}
	if err := payload0.convertFrom(nakedResponse.Archive); err != nil {
		return nil, nil, err
	}
	payload1 := &FTPServer{}
	if err := payload1.convertFrom(nakedResponse.FTPServer); err != nil {
		return nil, nil, err
	}
	return payload0, payload1, nil
}

// Read is API call
func (o *ArchiveOp) Read(ctx context.Context, zone string, id types.ID) (*Archive, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &archiveReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Archive{}
	if err := payload0.convertFrom(nakedResponse.Archive); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Update is API call
func (o *ArchiveOp) Update(ctx context.Context, zone string, id types.ID, param *ArchiveUpdateRequest) (*Archive, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &ArchiveUpdateRequest{}
		}
		if body == nil {
			body = &archiveUpdateRequestEnvelope{}
		}
		v := body.(*archiveUpdateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, err
		}
		v.Archive = n
		body = v
	}

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &archiveUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Archive{}
	if err := payload0.convertFrom(nakedResponse.Archive); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Delete is API call
func (o *ArchiveOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// OpenFTP is API call
func (o *ArchiveOp) OpenFTP(ctx context.Context, zone string, id types.ID, openOption *OpenFTPRequest) (*FTPServer, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/ftp", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"openOption": openOption,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if openOption == nil {
			openOption = &OpenFTPRequest{}
		}
		if body == nil {
			body = &archiveOpenFTPRequestEnvelope{}
		}
		v := body.(*archiveOpenFTPRequestEnvelope)
		if err := mapconv.ConvertTo(openOption, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &archiveOpenFTPResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &FTPServer{}
	if err := payload0.convertFrom(nakedResponse.FTPServer); err != nil {
		return nil, err
	}
	return payload0, nil
}

// CloseFTP is API call
func (o *ArchiveOp) CloseFTP(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/ftp", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* CDROMOp
*************************************************/

// CDROMOp implements CDROMAPI interface
type CDROMOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewCDROMOp creates new CDROMOp instance
func NewCDROMOp(caller APICaller) CDROMAPI {
	return GetClientFactoryFunc("CDROM")(caller).(CDROMAPI)
}

// Find is API call
func (o *CDROMOp) Find(ctx context.Context, zone string, conditions *FindCondition) ([]*CDROM, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if conditions == nil {
			conditions = &FindCondition{}
		}
		if body == nil {
			body = &cdromFindRequestEnvelope{}
		}
		v := body.(*cdromFindRequestEnvelope)
		if err := mapconv.ConvertTo(conditions, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &cdromFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	var payload0 []*CDROM
	for _, v := range nakedResponse.CDROMs {
		payload := &CDROM{}
		if err := payload.convertFrom(v); err != nil {
			return nil, err
		}
		payload0 = append(payload0, payload)
	}
	return payload0, nil
}

// Create is API call
func (o *CDROMOp) Create(ctx context.Context, zone string, param *CDROMCreateRequest) (*CDROM, *FTPServer, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &CDROMCreateRequest{}
		}
		if body == nil {
			body = &cdromCreateRequestEnvelope{}
		}
		v := body.(*cdromCreateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, nil, err
		}
		v.CDROM = n
		body = v
	}

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, nil, err
	}

	nakedResponse := &cdromCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, nil, err
	}

	payload0 := &CDROM{}
	if err := payload0.convertFrom(nakedResponse.CDROM); err != nil {
		return nil, nil, err
	}
	payload1 := &FTPServer{}
	if err := payload1.convertFrom(nakedResponse.FTPServer); err != nil {
		return nil, nil, err
	}
	return payload0, payload1, nil
}

// Read is API call
func (o *CDROMOp) Read(ctx context.Context, zone string, id types.ID) (*CDROM, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &cdromReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &CDROM{}
	if err := payload0.convertFrom(nakedResponse.CDROM); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Update is API call
func (o *CDROMOp) Update(ctx context.Context, zone string, id types.ID, param *CDROMUpdateRequest) (*CDROM, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &CDROMUpdateRequest{}
		}
		if body == nil {
			body = &cdromUpdateRequestEnvelope{}
		}
		v := body.(*cdromUpdateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, err
		}
		v.CDROM = n
		body = v
	}

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &cdromUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &CDROM{}
	if err := payload0.convertFrom(nakedResponse.CDROM); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Delete is API call
func (o *CDROMOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// OpenFTP is API call
func (o *CDROMOp) OpenFTP(ctx context.Context, zone string, id types.ID, openOption *OpenFTPRequest) (*FTPServer, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/ftp", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"openOption": openOption,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if openOption == nil {
			openOption = &OpenFTPRequest{}
		}
		if body == nil {
			body = &cdromOpenFTPRequestEnvelope{}
		}
		v := body.(*cdromOpenFTPRequestEnvelope)
		if err := mapconv.ConvertTo(openOption, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &cdromOpenFTPResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &FTPServer{}
	if err := payload0.convertFrom(nakedResponse.FTPServer); err != nil {
		return nil, err
	}
	return payload0, nil
}

// CloseFTP is API call
func (o *CDROMOp) CloseFTP(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/ftp", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* DiskOp
*************************************************/

// DiskOp implements DiskAPI interface
type DiskOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewDiskOp creates new DiskOp instance
func NewDiskOp(caller APICaller) DiskAPI {
	return GetClientFactoryFunc("Disk")(caller).(DiskAPI)
}

// Find is API call
func (o *DiskOp) Find(ctx context.Context, zone string, conditions *FindCondition) ([]*Disk, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if conditions == nil {
			conditions = &FindCondition{}
		}
		if body == nil {
			body = &diskFindRequestEnvelope{}
		}
		v := body.(*diskFindRequestEnvelope)
		if err := mapconv.ConvertTo(conditions, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	var payload0 []*Disk
	for _, v := range nakedResponse.Disks {
		payload := &Disk{}
		if err := payload.convertFrom(v); err != nil {
			return nil, err
		}
		payload0 = append(payload0, payload)
	}
	return payload0, nil
}

// Create is API call
func (o *DiskOp) Create(ctx context.Context, zone string, param *DiskCreateRequest) (*Disk, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &DiskCreateRequest{}
		}
		if body == nil {
			body = &diskCreateRequestEnvelope{}
		}
		v := body.(*diskCreateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, err
		}
		v.Disk = n
		body = v
	}

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Disk{}
	if err := payload0.convertFrom(nakedResponse.Disk); err != nil {
		return nil, err
	}
	return payload0, nil
}

// CreateDistantly is API call
func (o *DiskOp) CreateDistantly(ctx context.Context, zone string, createParam *DiskCreateRequest, distantFrom []types.ID) (*Disk, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":     SakuraCloudAPIRoot,
		"pathSuffix":  o.PathSuffix,
		"pathName":    o.PathName,
		"zone":        zone,
		"createParam": createParam,
		"distantFrom": distantFrom,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if createParam == nil {
			createParam = &DiskCreateRequest{}
		}
		if body == nil {
			body = &diskCreateDistantlyRequestEnvelope{}
		}
		v := body.(*diskCreateDistantlyRequestEnvelope)
		n, err := createParam.convertTo()
		if err != nil {
			return nil, err
		}
		v.Disk = n
		body = v
	}

	{
		if body == nil {
			body = &diskCreateDistantlyRequestEnvelope{}
		}
		v := body.(*diskCreateDistantlyRequestEnvelope)
		v.DistantFrom = distantFrom
		body = v
	}

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskCreateDistantlyResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Disk{}
	if err := payload0.convertFrom(nakedResponse.Disk); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Config is API call
func (o *DiskOp) Config(ctx context.Context, zone string, id types.ID, edit *DiskEditRequest) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/config", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"edit":       edit,
	})
	if err != nil {
		return err
	}

	var body interface{}
	{
		if edit == nil {
			edit = &DiskEditRequest{}
		}
		if body == nil {
			body = &diskConfigRequestEnvelope{}
		}
		v := body.(*diskConfigRequestEnvelope)
		if err := mapconv.ConvertTo(edit, v); err != nil {
			return err
		}
		body = v
	}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// CreateWithConfig is API call
func (o *DiskOp) CreateWithConfig(ctx context.Context, zone string, createParam *DiskCreateRequest, editParam *DiskEditRequest, bootAtAvailable bool) (*Disk, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":         SakuraCloudAPIRoot,
		"pathSuffix":      o.PathSuffix,
		"pathName":        o.PathName,
		"zone":            zone,
		"createParam":     createParam,
		"editParam":       editParam,
		"bootAtAvailable": bootAtAvailable,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if createParam == nil {
			createParam = &DiskCreateRequest{}
		}
		if body == nil {
			body = &diskCreateWithConfigRequestEnvelope{}
		}
		v := body.(*diskCreateWithConfigRequestEnvelope)
		n, err := createParam.convertTo()
		if err != nil {
			return nil, err
		}
		v.Disk = n
		body = v
	}

	{
		if editParam == nil {
			editParam = &DiskEditRequest{}
		}
		if body == nil {
			body = &diskCreateWithConfigRequestEnvelope{}
		}
		v := body.(*diskCreateWithConfigRequestEnvelope)
		n, err := editParam.convertTo()
		if err != nil {
			return nil, err
		}
		v.Config = n
		body = v
	}

	{
		if body == nil {
			body = &diskCreateWithConfigRequestEnvelope{}
		}
		v := body.(*diskCreateWithConfigRequestEnvelope)
		v.BootAtAvailable = bootAtAvailable
		body = v
	}

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskCreateWithConfigResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Disk{}
	if err := payload0.convertFrom(nakedResponse.Disk); err != nil {
		return nil, err
	}
	return payload0, nil
}

// CreateWithConfigDistantly is API call
func (o *DiskOp) CreateWithConfigDistantly(ctx context.Context, zone string, createParam *DiskCreateRequest, editParam *DiskEditRequest, bootAtAvailable bool, distantFrom []types.ID) (*Disk, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":         SakuraCloudAPIRoot,
		"pathSuffix":      o.PathSuffix,
		"pathName":        o.PathName,
		"zone":            zone,
		"createParam":     createParam,
		"editParam":       editParam,
		"bootAtAvailable": bootAtAvailable,
		"distantFrom":     distantFrom,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if createParam == nil {
			createParam = &DiskCreateRequest{}
		}
		if body == nil {
			body = &diskCreateWithConfigDistantlyRequestEnvelope{}
		}
		v := body.(*diskCreateWithConfigDistantlyRequestEnvelope)
		n, err := createParam.convertTo()
		if err != nil {
			return nil, err
		}
		v.Disk = n
		body = v
	}

	{
		if editParam == nil {
			editParam = &DiskEditRequest{}
		}
		if body == nil {
			body = &diskCreateWithConfigDistantlyRequestEnvelope{}
		}
		v := body.(*diskCreateWithConfigDistantlyRequestEnvelope)
		n, err := editParam.convertTo()
		if err != nil {
			return nil, err
		}
		v.Config = n
		body = v
	}

	{
		if body == nil {
			body = &diskCreateWithConfigDistantlyRequestEnvelope{}
		}
		v := body.(*diskCreateWithConfigDistantlyRequestEnvelope)
		v.BootAtAvailable = bootAtAvailable
		body = v
	}

	{
		if body == nil {
			body = &diskCreateWithConfigDistantlyRequestEnvelope{}
		}
		v := body.(*diskCreateWithConfigDistantlyRequestEnvelope)
		v.DistantFrom = distantFrom
		body = v
	}

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskCreateWithConfigDistantlyResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Disk{}
	if err := payload0.convertFrom(nakedResponse.Disk); err != nil {
		return nil, err
	}
	return payload0, nil
}

// ToBlank is API call
func (o *DiskOp) ToBlank(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/blank", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ResizePartition is API call
func (o *DiskOp) ResizePartition(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/resize-partition", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ConnectToServer is API call
func (o *DiskOp) ConnectToServer(ctx context.Context, zone string, id types.ID, serverID types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/server/{{.serverID}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"serverID":   serverID,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// DisconnectFromServer is API call
func (o *DiskOp) DisconnectFromServer(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/server", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// InstallDistantFrom is API call
func (o *DiskOp) InstallDistantFrom(ctx context.Context, zone string, id types.ID, installParam *DiskInstallRequest, distantFrom []types.ID) (*Disk, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/install", map[string]interface{}{
		"rootURL":      SakuraCloudAPIRoot,
		"pathSuffix":   o.PathSuffix,
		"pathName":     o.PathName,
		"zone":         zone,
		"id":           id,
		"installParam": installParam,
		"distantFrom":  distantFrom,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if installParam == nil {
			installParam = &DiskInstallRequest{}
		}
		if body == nil {
			body = &diskInstallDistantFromRequestEnvelope{}
		}
		v := body.(*diskInstallDistantFromRequestEnvelope)
		n, err := installParam.convertTo()
		if err != nil {
			return nil, err
		}
		v.Disk = n
		body = v
	}

	{
		if body == nil {
			body = &diskInstallDistantFromRequestEnvelope{}
		}
		v := body.(*diskInstallDistantFromRequestEnvelope)
		v.DistantFrom = distantFrom
		body = v
	}

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskInstallDistantFromResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Disk{}
	if err := payload0.convertFrom(nakedResponse.Disk); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Install is API call
func (o *DiskOp) Install(ctx context.Context, zone string, id types.ID, installParam *DiskInstallRequest) (*Disk, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/install", map[string]interface{}{
		"rootURL":      SakuraCloudAPIRoot,
		"pathSuffix":   o.PathSuffix,
		"pathName":     o.PathName,
		"zone":         zone,
		"id":           id,
		"installParam": installParam,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if installParam == nil {
			installParam = &DiskInstallRequest{}
		}
		if body == nil {
			body = &diskInstallRequestEnvelope{}
		}
		v := body.(*diskInstallRequestEnvelope)
		n, err := installParam.convertTo()
		if err != nil {
			return nil, err
		}
		v.Disk = n
		body = v
	}

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskInstallResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Disk{}
	if err := payload0.convertFrom(nakedResponse.Disk); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Read is API call
func (o *DiskOp) Read(ctx context.Context, zone string, id types.ID) (*Disk, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Disk{}
	if err := payload0.convertFrom(nakedResponse.Disk); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Update is API call
func (o *DiskOp) Update(ctx context.Context, zone string, id types.ID, param *DiskUpdateRequest) (*Disk, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &DiskUpdateRequest{}
		}
		if body == nil {
			body = &diskUpdateRequestEnvelope{}
		}
		v := body.(*diskUpdateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, err
		}
		v.Disk = n
		body = v
	}

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Disk{}
	if err := payload0.convertFrom(nakedResponse.Disk); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Delete is API call
func (o *DiskOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Monitor is API call
func (o *DiskOp) Monitor(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*DiskActivity, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if condition == nil {
			condition = &MonitorCondition{}
		}
		if body == nil {
			body = &diskMonitorRequestEnvelope{}
		}
		v := body.(*diskMonitorRequestEnvelope)
		if err := mapconv.ConvertTo(condition, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &diskMonitorResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &DiskActivity{}
	if err := payload0.convertFrom(nakedResponse.Data); err != nil {
		return nil, err
	}
	return payload0, nil
}

/*************************************************
* GSLBOp
*************************************************/

// GSLBOp implements GSLBAPI interface
type GSLBOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewGSLBOp creates new GSLBOp instance
func NewGSLBOp(caller APICaller) GSLBAPI {
	return GetClientFactoryFunc("GSLB")(caller).(GSLBAPI)
}

// Find is API call
func (o *GSLBOp) Find(ctx context.Context, zone string, conditions *FindCondition) ([]*GSLB, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if conditions == nil {
			conditions = &FindCondition{}
		}
		if body == nil {
			body = &gslbFindRequestEnvelope{}
		}
		v := body.(*gslbFindRequestEnvelope)
		if err := mapconv.ConvertTo(conditions, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &gslbFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	var payload0 []*GSLB
	for _, v := range nakedResponse.CommonServiceItems {
		payload := &GSLB{}
		if err := payload.convertFrom(v); err != nil {
			return nil, err
		}
		payload0 = append(payload0, payload)
	}
	return payload0, nil
}

// Create is API call
func (o *GSLBOp) Create(ctx context.Context, zone string, param *GSLBCreateRequest) (*GSLB, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &GSLBCreateRequest{}
		}
		if body == nil {
			body = &gslbCreateRequestEnvelope{}
		}
		v := body.(*gslbCreateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, err
		}
		v.CommonServiceItem = n
		body = v
	}

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &gslbCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &GSLB{}
	if err := payload0.convertFrom(nakedResponse.CommonServiceItem); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Read is API call
func (o *GSLBOp) Read(ctx context.Context, zone string, id types.ID) (*GSLB, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &gslbReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &GSLB{}
	if err := payload0.convertFrom(nakedResponse.CommonServiceItem); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Update is API call
func (o *GSLBOp) Update(ctx context.Context, zone string, id types.ID, param *GSLBUpdateRequest) (*GSLB, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &GSLBUpdateRequest{}
		}
		if body == nil {
			body = &gslbUpdateRequestEnvelope{}
		}
		v := body.(*gslbUpdateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, err
		}
		v.CommonServiceItem = n
		body = v
	}

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &gslbUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &GSLB{}
	if err := payload0.convertFrom(nakedResponse.CommonServiceItem); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Delete is API call
func (o *GSLBOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* InterfaceOp
*************************************************/

// InterfaceOp implements InterfaceAPI interface
type InterfaceOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewInterfaceOp creates new InterfaceOp instance
func NewInterfaceOp(caller APICaller) InterfaceAPI {
	return GetClientFactoryFunc("Interface")(caller).(InterfaceAPI)
}

// Find is API call
func (o *InterfaceOp) Find(ctx context.Context, zone string, conditions *FindCondition) ([]*Interface, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if conditions == nil {
			conditions = &FindCondition{}
		}
		if body == nil {
			body = &interfaceFindRequestEnvelope{}
		}
		v := body.(*interfaceFindRequestEnvelope)
		if err := mapconv.ConvertTo(conditions, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &interfaceFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	var payload0 []*Interface
	for _, v := range nakedResponse.Interfaces {
		payload := &Interface{}
		if err := payload.convertFrom(v); err != nil {
			return nil, err
		}
		payload0 = append(payload0, payload)
	}
	return payload0, nil
}

// Create is API call
func (o *InterfaceOp) Create(ctx context.Context, zone string, param *InterfaceCreateRequest) (*Interface, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &InterfaceCreateRequest{}
		}
		if body == nil {
			body = &interfaceCreateRequestEnvelope{}
		}
		v := body.(*interfaceCreateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, err
		}
		v.Interface = n
		body = v
	}

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &interfaceCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Interface{}
	if err := payload0.convertFrom(nakedResponse.Interface); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Read is API call
func (o *InterfaceOp) Read(ctx context.Context, zone string, id types.ID) (*Interface, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &interfaceReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Interface{}
	if err := payload0.convertFrom(nakedResponse.Interface); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Update is API call
func (o *InterfaceOp) Update(ctx context.Context, zone string, id types.ID, param *InterfaceUpdateRequest) (*Interface, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &InterfaceUpdateRequest{}
		}
		if body == nil {
			body = &interfaceUpdateRequestEnvelope{}
		}
		v := body.(*interfaceUpdateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, err
		}
		v.Interface = n
		body = v
	}

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &interfaceUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Interface{}
	if err := payload0.convertFrom(nakedResponse.Interface); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Delete is API call
func (o *InterfaceOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Monitor is API call
func (o *InterfaceOp) Monitor(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*InterfaceActivity, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if condition == nil {
			condition = &MonitorCondition{}
		}
		if body == nil {
			body = &interfaceMonitorRequestEnvelope{}
		}
		v := body.(*interfaceMonitorRequestEnvelope)
		if err := mapconv.ConvertTo(condition, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &interfaceMonitorResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &InterfaceActivity{}
	if err := payload0.convertFrom(nakedResponse.Data); err != nil {
		return nil, err
	}
	return payload0, nil
}

// ConnectToSharedSegment is API call
func (o *InterfaceOp) ConnectToSharedSegment(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/switch/shared", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ConnectToSwitch is API call
func (o *InterfaceOp) ConnectToSwitch(ctx context.Context, zone string, id types.ID, switchID types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/switch/{{.switchID}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"switchID":   switchID,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// DisconnectFromSwitch is API call
func (o *InterfaceOp) DisconnectFromSwitch(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/switch", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ConnectToPacketFilter is API call
func (o *InterfaceOp) ConnectToPacketFilter(ctx context.Context, zone string, id types.ID, packetFilterID types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/packetfilter/{{.packetFilterID}}", map[string]interface{}{
		"rootURL":        SakuraCloudAPIRoot,
		"pathSuffix":     o.PathSuffix,
		"pathName":       o.PathName,
		"zone":           zone,
		"id":             id,
		"packetFilterID": packetFilterID,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// DisconnectFromPacketFilter is API call
func (o *InterfaceOp) DisconnectFromPacketFilter(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/packetfilter", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* LoadBalancerOp
*************************************************/

// LoadBalancerOp implements LoadBalancerAPI interface
type LoadBalancerOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewLoadBalancerOp creates new LoadBalancerOp instance
func NewLoadBalancerOp(caller APICaller) LoadBalancerAPI {
	return GetClientFactoryFunc("LoadBalancer")(caller).(LoadBalancerAPI)
}

// Find is API call
func (o *LoadBalancerOp) Find(ctx context.Context, zone string, conditions *FindCondition) ([]*LoadBalancer, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if conditions == nil {
			conditions = &FindCondition{}
		}
		if body == nil {
			body = &loadbalancerFindRequestEnvelope{}
		}
		v := body.(*loadbalancerFindRequestEnvelope)
		if err := mapconv.ConvertTo(conditions, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &loadbalancerFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	var payload0 []*LoadBalancer
	for _, v := range nakedResponse.Appliances {
		payload := &LoadBalancer{}
		if err := payload.convertFrom(v); err != nil {
			return nil, err
		}
		payload0 = append(payload0, payload)
	}
	return payload0, nil
}

// Create is API call
func (o *LoadBalancerOp) Create(ctx context.Context, zone string, param *LoadBalancerCreateRequest) (*LoadBalancer, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &LoadBalancerCreateRequest{}
		}
		if body == nil {
			body = &loadbalancerCreateRequestEnvelope{}
		}
		v := body.(*loadbalancerCreateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, err
		}
		v.Appliance = n
		body = v
	}

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &loadbalancerCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &LoadBalancer{}
	if err := payload0.convertFrom(nakedResponse.Appliance); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Read is API call
func (o *LoadBalancerOp) Read(ctx context.Context, zone string, id types.ID) (*LoadBalancer, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &loadbalancerReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &LoadBalancer{}
	if err := payload0.convertFrom(nakedResponse.Appliance); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Update is API call
func (o *LoadBalancerOp) Update(ctx context.Context, zone string, id types.ID, param *LoadBalancerUpdateRequest) (*LoadBalancer, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &LoadBalancerUpdateRequest{}
		}
		if body == nil {
			body = &loadbalancerUpdateRequestEnvelope{}
		}
		v := body.(*loadbalancerUpdateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, err
		}
		v.Appliance = n
		body = v
	}

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &loadbalancerUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &LoadBalancer{}
	if err := payload0.convertFrom(nakedResponse.Appliance); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Delete is API call
func (o *LoadBalancerOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Config is API call
func (o *LoadBalancerOp) Config(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/config", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Boot is API call
func (o *LoadBalancerOp) Boot(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Shutdown is API call
func (o *LoadBalancerOp) Shutdown(ctx context.Context, zone string, id types.ID, shutdownOption *ShutdownOption) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":        SakuraCloudAPIRoot,
		"pathSuffix":     o.PathSuffix,
		"pathName":       o.PathName,
		"zone":           zone,
		"id":             id,
		"shutdownOption": shutdownOption,
	})
	if err != nil {
		return err
	}

	var body interface{}
	{
		if shutdownOption == nil {
			shutdownOption = &ShutdownOption{}
		}
		if body == nil {
			body = &loadbalancerShutdownRequestEnvelope{}
		}
		v := body.(*loadbalancerShutdownRequestEnvelope)
		if err := mapconv.ConvertTo(shutdownOption, v); err != nil {
			return err
		}
		body = v
	}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Reset is API call
func (o *LoadBalancerOp) Reset(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/reset", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// MonitorInterface is API call
func (o *LoadBalancerOp) MonitorInterface(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*InterfaceActivity, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/interface/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if condition == nil {
			condition = &MonitorCondition{}
		}
		if body == nil {
			body = &loadbalancerMonitorInterfaceRequestEnvelope{}
		}
		v := body.(*loadbalancerMonitorInterfaceRequestEnvelope)
		if err := mapconv.ConvertTo(condition, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &loadbalancerMonitorInterfaceResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &InterfaceActivity{}
	if err := payload0.convertFrom(nakedResponse.Data); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Status is API call
func (o *LoadBalancerOp) Status(ctx context.Context, zone string, id types.ID) ([]*LoadBalancerStatus, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/status", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &loadbalancerStatusResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	var payload0 []*LoadBalancerStatus
	for _, v := range nakedResponse.LoadBalancer {
		payload := &LoadBalancerStatus{}
		if err := payload.convertFrom(v); err != nil {
			return nil, err
		}
		payload0 = append(payload0, payload)
	}
	return payload0, nil
}

/*************************************************
* NFSOp
*************************************************/

// NFSOp implements NFSAPI interface
type NFSOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewNFSOp creates new NFSOp instance
func NewNFSOp(caller APICaller) NFSAPI {
	return GetClientFactoryFunc("NFS")(caller).(NFSAPI)
}

// Find is API call
func (o *NFSOp) Find(ctx context.Context, zone string, conditions *FindCondition) ([]*NFS, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if conditions == nil {
			conditions = &FindCondition{}
		}
		if body == nil {
			body = &nfsFindRequestEnvelope{}
		}
		v := body.(*nfsFindRequestEnvelope)
		if err := mapconv.ConvertTo(conditions, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &nfsFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	var payload0 []*NFS
	for _, v := range nakedResponse.Appliances {
		payload := &NFS{}
		if err := payload.convertFrom(v); err != nil {
			return nil, err
		}
		payload0 = append(payload0, payload)
	}
	return payload0, nil
}

// Create is API call
func (o *NFSOp) Create(ctx context.Context, zone string, param *NFSCreateRequest) (*NFS, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &NFSCreateRequest{}
		}
		if body == nil {
			body = &nfsCreateRequestEnvelope{}
		}
		v := body.(*nfsCreateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, err
		}
		v.Appliance = n
		body = v
	}

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &nfsCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &NFS{}
	if err := payload0.convertFrom(nakedResponse.Appliance); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Read is API call
func (o *NFSOp) Read(ctx context.Context, zone string, id types.ID) (*NFS, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &nfsReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &NFS{}
	if err := payload0.convertFrom(nakedResponse.Appliance); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Update is API call
func (o *NFSOp) Update(ctx context.Context, zone string, id types.ID, param *NFSUpdateRequest) (*NFS, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &NFSUpdateRequest{}
		}
		if body == nil {
			body = &nfsUpdateRequestEnvelope{}
		}
		v := body.(*nfsUpdateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, err
		}
		v.Appliance = n
		body = v
	}

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &nfsUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &NFS{}
	if err := payload0.convertFrom(nakedResponse.Appliance); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Delete is API call
func (o *NFSOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Boot is API call
func (o *NFSOp) Boot(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Shutdown is API call
func (o *NFSOp) Shutdown(ctx context.Context, zone string, id types.ID, shutdownOption *ShutdownOption) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":        SakuraCloudAPIRoot,
		"pathSuffix":     o.PathSuffix,
		"pathName":       o.PathName,
		"zone":           zone,
		"id":             id,
		"shutdownOption": shutdownOption,
	})
	if err != nil {
		return err
	}

	var body interface{}
	{
		if shutdownOption == nil {
			shutdownOption = &ShutdownOption{}
		}
		if body == nil {
			body = &nfsShutdownRequestEnvelope{}
		}
		v := body.(*nfsShutdownRequestEnvelope)
		if err := mapconv.ConvertTo(shutdownOption, v); err != nil {
			return err
		}
		body = v
	}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Reset is API call
func (o *NFSOp) Reset(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/reset", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// MonitorFreeDiskSize is API call
func (o *NFSOp) MonitorFreeDiskSize(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*FreeDiskSizeActivity, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/database/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if condition == nil {
			condition = &MonitorCondition{}
		}
		if body == nil {
			body = &nfsMonitorFreeDiskSizeRequestEnvelope{}
		}
		v := body.(*nfsMonitorFreeDiskSizeRequestEnvelope)
		if err := mapconv.ConvertTo(condition, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &nfsMonitorFreeDiskSizeResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &FreeDiskSizeActivity{}
	if err := payload0.convertFrom(nakedResponse.Data); err != nil {
		return nil, err
	}
	return payload0, nil
}

// MonitorInterface is API call
func (o *NFSOp) MonitorInterface(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*InterfaceActivity, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/interface/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if condition == nil {
			condition = &MonitorCondition{}
		}
		if body == nil {
			body = &nfsMonitorInterfaceRequestEnvelope{}
		}
		v := body.(*nfsMonitorInterfaceRequestEnvelope)
		if err := mapconv.ConvertTo(condition, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &nfsMonitorInterfaceResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &InterfaceActivity{}
	if err := payload0.convertFrom(nakedResponse.Data); err != nil {
		return nil, err
	}
	return payload0, nil
}

/*************************************************
* NoteOp
*************************************************/

// NoteOp implements NoteAPI interface
type NoteOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewNoteOp creates new NoteOp instance
func NewNoteOp(caller APICaller) NoteAPI {
	return GetClientFactoryFunc("Note")(caller).(NoteAPI)
}

// Find is API call
func (o *NoteOp) Find(ctx context.Context, zone string, conditions *FindCondition) ([]*Note, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if conditions == nil {
			conditions = &FindCondition{}
		}
		if body == nil {
			body = &noteFindRequestEnvelope{}
		}
		v := body.(*noteFindRequestEnvelope)
		if err := mapconv.ConvertTo(conditions, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &noteFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	var payload0 []*Note
	for _, v := range nakedResponse.Notes {
		payload := &Note{}
		if err := payload.convertFrom(v); err != nil {
			return nil, err
		}
		payload0 = append(payload0, payload)
	}
	return payload0, nil
}

// Create is API call
func (o *NoteOp) Create(ctx context.Context, zone string, param *NoteCreateRequest) (*Note, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &NoteCreateRequest{}
		}
		if body == nil {
			body = &noteCreateRequestEnvelope{}
		}
		v := body.(*noteCreateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, err
		}
		v.Note = n
		body = v
	}

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &noteCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Note{}
	if err := payload0.convertFrom(nakedResponse.Note); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Read is API call
func (o *NoteOp) Read(ctx context.Context, zone string, id types.ID) (*Note, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &noteReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Note{}
	if err := payload0.convertFrom(nakedResponse.Note); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Update is API call
func (o *NoteOp) Update(ctx context.Context, zone string, id types.ID, param *NoteUpdateRequest) (*Note, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &NoteUpdateRequest{}
		}
		if body == nil {
			body = &noteUpdateRequestEnvelope{}
		}
		v := body.(*noteUpdateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, err
		}
		v.Note = n
		body = v
	}

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &noteUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Note{}
	if err := payload0.convertFrom(nakedResponse.Note); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Delete is API call
func (o *NoteOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* ServerOp
*************************************************/

// ServerOp implements ServerAPI interface
type ServerOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewServerOp creates new ServerOp instance
func NewServerOp(caller APICaller) ServerAPI {
	return GetClientFactoryFunc("Server")(caller).(ServerAPI)
}

// Find is API call
func (o *ServerOp) Find(ctx context.Context, zone string, conditions *FindCondition) ([]*Server, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if conditions == nil {
			conditions = &FindCondition{}
		}
		if body == nil {
			body = &serverFindRequestEnvelope{}
		}
		v := body.(*serverFindRequestEnvelope)
		if err := mapconv.ConvertTo(conditions, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &serverFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	var payload0 []*Server
	for _, v := range nakedResponse.Servers {
		payload := &Server{}
		if err := payload.convertFrom(v); err != nil {
			return nil, err
		}
		payload0 = append(payload0, payload)
	}
	return payload0, nil
}

// Create is API call
func (o *ServerOp) Create(ctx context.Context, zone string, param *ServerCreateRequest) (*Server, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &ServerCreateRequest{}
		}
		if body == nil {
			body = &serverCreateRequestEnvelope{}
		}
		v := body.(*serverCreateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, err
		}
		v.Server = n
		body = v
	}

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &serverCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Server{}
	if err := payload0.convertFrom(nakedResponse.Server); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Read is API call
func (o *ServerOp) Read(ctx context.Context, zone string, id types.ID) (*Server, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &serverReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Server{}
	if err := payload0.convertFrom(nakedResponse.Server); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Update is API call
func (o *ServerOp) Update(ctx context.Context, zone string, id types.ID, param *ServerUpdateRequest) (*Server, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &ServerUpdateRequest{}
		}
		if body == nil {
			body = &serverUpdateRequestEnvelope{}
		}
		v := body.(*serverUpdateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, err
		}
		v.Server = n
		body = v
	}

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &serverUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Server{}
	if err := payload0.convertFrom(nakedResponse.Server); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Delete is API call
func (o *ServerOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ChangePlan is API call
func (o *ServerOp) ChangePlan(ctx context.Context, zone string, id types.ID, plan *ServerChangePlanRequest) (*Server, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/plan", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"plan":       plan,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if plan == nil {
			plan = &ServerChangePlanRequest{}
		}
		if body == nil {
			body = &serverChangePlanRequestEnvelope{}
		}
		v := body.(*serverChangePlanRequestEnvelope)
		if err := mapconv.ConvertTo(plan, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &serverChangePlanResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Server{}
	if err := payload0.convertFrom(nakedResponse.Server); err != nil {
		return nil, err
	}
	return payload0, nil
}

// InsertCDROM is API call
func (o *ServerOp) InsertCDROM(ctx context.Context, zone string, id types.ID, insertParam *InsertCDROMRequest) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/cdrom", map[string]interface{}{
		"rootURL":     SakuraCloudAPIRoot,
		"pathSuffix":  o.PathSuffix,
		"pathName":    o.PathName,
		"zone":        zone,
		"id":          id,
		"insertParam": insertParam,
	})
	if err != nil {
		return err
	}

	var body interface{}

	{
		if insertParam == nil {
			insertParam = &InsertCDROMRequest{}
		}
		if body == nil {
			body = &serverInsertCDROMRequestEnvelope{}
		}
		v := body.(*serverInsertCDROMRequestEnvelope)
		n, err := insertParam.convertTo()
		if err != nil {
			return err
		}
		v.CDROM = n
		body = v
	}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// EjectCDROM is API call
func (o *ServerOp) EjectCDROM(ctx context.Context, zone string, id types.ID, insertParam *EjectCDROMRequest) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/cdrom", map[string]interface{}{
		"rootURL":     SakuraCloudAPIRoot,
		"pathSuffix":  o.PathSuffix,
		"pathName":    o.PathName,
		"zone":        zone,
		"id":          id,
		"insertParam": insertParam,
	})
	if err != nil {
		return err
	}

	var body interface{}

	{
		if insertParam == nil {
			insertParam = &EjectCDROMRequest{}
		}
		if body == nil {
			body = &serverEjectCDROMRequestEnvelope{}
		}
		v := body.(*serverEjectCDROMRequestEnvelope)
		n, err := insertParam.convertTo()
		if err != nil {
			return err
		}
		v.CDROM = n
		body = v
	}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Boot is API call
func (o *ServerOp) Boot(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Shutdown is API call
func (o *ServerOp) Shutdown(ctx context.Context, zone string, id types.ID, shutdownOption *ShutdownOption) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":        SakuraCloudAPIRoot,
		"pathSuffix":     o.PathSuffix,
		"pathName":       o.PathName,
		"zone":           zone,
		"id":             id,
		"shutdownOption": shutdownOption,
	})
	if err != nil {
		return err
	}

	var body interface{}
	{
		if shutdownOption == nil {
			shutdownOption = &ShutdownOption{}
		}
		if body == nil {
			body = &serverShutdownRequestEnvelope{}
		}
		v := body.(*serverShutdownRequestEnvelope)
		if err := mapconv.ConvertTo(shutdownOption, v); err != nil {
			return err
		}
		body = v
	}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Reset is API call
func (o *ServerOp) Reset(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/reset", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Monitor is API call
func (o *ServerOp) Monitor(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*CPUTimeActivity, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if condition == nil {
			condition = &MonitorCondition{}
		}
		if body == nil {
			body = &serverMonitorRequestEnvelope{}
		}
		v := body.(*serverMonitorRequestEnvelope)
		if err := mapconv.ConvertTo(condition, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &serverMonitorResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &CPUTimeActivity{}
	if err := payload0.convertFrom(nakedResponse.Data); err != nil {
		return nil, err
	}
	return payload0, nil
}

/*************************************************
* SwitchOp
*************************************************/

// SwitchOp implements SwitchAPI interface
type SwitchOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewSwitchOp creates new SwitchOp instance
func NewSwitchOp(caller APICaller) SwitchAPI {
	return GetClientFactoryFunc("Switch")(caller).(SwitchAPI)
}

// Find is API call
func (o *SwitchOp) Find(ctx context.Context, zone string, conditions *FindCondition) ([]*Switch, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if conditions == nil {
			conditions = &FindCondition{}
		}
		if body == nil {
			body = &switchFindRequestEnvelope{}
		}
		v := body.(*switchFindRequestEnvelope)
		if err := mapconv.ConvertTo(conditions, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &switchFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	var payload0 []*Switch
	for _, v := range nakedResponse.Switches {
		payload := &Switch{}
		if err := payload.convertFrom(v); err != nil {
			return nil, err
		}
		payload0 = append(payload0, payload)
	}
	return payload0, nil
}

// Create is API call
func (o *SwitchOp) Create(ctx context.Context, zone string, param *SwitchCreateRequest) (*Switch, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &SwitchCreateRequest{}
		}
		if body == nil {
			body = &switchCreateRequestEnvelope{}
		}
		v := body.(*switchCreateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, err
		}
		v.Switch = n
		body = v
	}

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &switchCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Switch{}
	if err := payload0.convertFrom(nakedResponse.Switch); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Read is API call
func (o *SwitchOp) Read(ctx context.Context, zone string, id types.ID) (*Switch, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &switchReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Switch{}
	if err := payload0.convertFrom(nakedResponse.Switch); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Update is API call
func (o *SwitchOp) Update(ctx context.Context, zone string, id types.ID, param *SwitchUpdateRequest) (*Switch, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &SwitchUpdateRequest{}
		}
		if body == nil {
			body = &switchUpdateRequestEnvelope{}
		}
		v := body.(*switchUpdateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, err
		}
		v.Switch = n
		body = v
	}

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &switchUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Switch{}
	if err := payload0.convertFrom(nakedResponse.Switch); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Delete is API call
func (o *SwitchOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ConnectToBridge is API call
func (o *SwitchOp) ConnectToBridge(ctx context.Context, zone string, id types.ID, bridgeID types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/bridge/{{.bridgeID}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"bridgeID":   bridgeID,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// DisconnectFromBridge is API call
func (o *SwitchOp) DisconnectFromBridge(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/bridge", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* ZoneOp
*************************************************/

// ZoneOp implements ZoneAPI interface
type ZoneOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewZoneOp creates new ZoneOp instance
func NewZoneOp(caller APICaller) ZoneAPI {
	return GetClientFactoryFunc("Zone")(caller).(ZoneAPI)
}

// Find is API call
func (o *ZoneOp) Find(ctx context.Context, zone string, conditions *FindCondition) ([]*Zone, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if conditions == nil {
			conditions = &FindCondition{}
		}
		if body == nil {
			body = &zoneFindRequestEnvelope{}
		}
		v := body.(*zoneFindRequestEnvelope)
		if err := mapconv.ConvertTo(conditions, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &zoneFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	var payload0 []*Zone
	for _, v := range nakedResponse.Zones {
		payload := &Zone{}
		if err := payload.convertFrom(v); err != nil {
			return nil, err
		}
		payload0 = append(payload0, payload)
	}
	return payload0, nil
}

// Read is API call
func (o *ZoneOp) Read(ctx context.Context, zone string, id types.ID) (*Zone, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &zoneReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Zone{}
	if err := payload0.convertFrom(nakedResponse.Zone); err != nil {
		return nil, err
	}
	return payload0, nil
}
