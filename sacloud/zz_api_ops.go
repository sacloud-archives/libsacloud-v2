// generated by 'github.com/sacloud/libsacloud/internal/tools/gen-api-op'; DO NOT EDIT

package sacloud

import (
	"context"
	"encoding/json"

	"github.com/sacloud/libsacloud-v2/pkg/mapconv"
	"github.com/sacloud/libsacloud-v2/sacloud/types"
)

/*************************************************
* ArchiveOp
*************************************************/

// ArchiveOp implements ArchiveAPI interface
type ArchiveOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewArchiveOp creates new ArchiveOp instance
func NewArchiveOp(client APICaller) ArchiveAPI {
	return &ArchiveOp{
		Client:     client,
		PathSuffix: "api/cloud/1.1",
		PathName:   "archive",
	}
}

// Find is API call
func (o *ArchiveOp) Find(ctx context.Context, zone string, conditions *FindCondition) ([]*Archive, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if conditions == nil {
			conditions = &FindCondition{}
		}
		if body == nil {
			body = &ArchiveFindRequestEnvelope{}
		}
		v := body.(*ArchiveFindRequestEnvelope)
		if err := mapconv.ConvertTo(conditions, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &ArchiveFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	var payload0 []*Archive
	for _, v := range nakedResponse.Archives {
		payload := &Archive{}
		if err := payload.convertFrom(v); err != nil {
			return nil, err
		}
		payload0 = append(payload0, payload)
	}
	return payload0, nil
}

// Create is API call
func (o *ArchiveOp) Create(ctx context.Context, zone string, param *ArchiveCreateRequest) (*Archive, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &ArchiveCreateRequest{}
		}
		if body == nil {
			body = &ArchiveCreateRequestEnvelope{}
		}
		v := body.(*ArchiveCreateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, err
		}
		v.Archive = n
		body = v
	}

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &ArchiveCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Archive{}
	if err := payload0.convertFrom(nakedResponse.Archive); err != nil {
		return nil, err
	}
	return payload0, nil
}

// CreateBlank is API call
func (o *ArchiveOp) CreateBlank(ctx context.Context, zone string, param *ArchiveCreateBlankRequest) (*Archive, *FTPServer, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &ArchiveCreateBlankRequest{}
		}
		if body == nil {
			body = &ArchiveCreateBlankRequestEnvelope{}
		}
		v := body.(*ArchiveCreateBlankRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, nil, err
		}
		v.Archive = n
		body = v
	}

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, nil, err
	}

	nakedResponse := &ArchiveCreateBlankResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, nil, err
	}

	payload0 := &Archive{}
	if err := payload0.convertFrom(nakedResponse.Archive); err != nil {
		return nil, nil, err
	}
	payload1 := &FTPServer{}
	if err := payload1.convertFrom(nakedResponse.FTPServer); err != nil {
		return nil, nil, err
	}
	return payload0, payload1, nil
}

// Read is API call
func (o *ArchiveOp) Read(ctx context.Context, zone string, id types.ID) (*Archive, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &ArchiveReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Archive{}
	if err := payload0.convertFrom(nakedResponse.Archive); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Update is API call
func (o *ArchiveOp) Update(ctx context.Context, zone string, id types.ID, param *ArchiveUpdateRequest) (*Archive, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &ArchiveUpdateRequest{}
		}
		if body == nil {
			body = &ArchiveUpdateRequestEnvelope{}
		}
		v := body.(*ArchiveUpdateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, err
		}
		v.Archive = n
		body = v
	}

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &ArchiveUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Archive{}
	if err := payload0.convertFrom(nakedResponse.Archive); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Delete is API call
func (o *ArchiveOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// OpenFTP is API call
func (o *ArchiveOp) OpenFTP(ctx context.Context, zone string, id types.ID, openOption *OpenFTPRequest) (*FTPServer, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/ftp", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"openOption": openOption,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if openOption == nil {
			openOption = &OpenFTPRequest{}
		}
		if body == nil {
			body = &ArchiveOpenFTPRequestEnvelope{}
		}
		v := body.(*ArchiveOpenFTPRequestEnvelope)
		if err := mapconv.ConvertTo(openOption, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &ArchiveOpenFTPResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &FTPServer{}
	if err := payload0.convertFrom(nakedResponse.FTPServer); err != nil {
		return nil, err
	}
	return payload0, nil
}

// CloseFTP is API call
func (o *ArchiveOp) CloseFTP(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/ftp", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* CDROMOp
*************************************************/

// CDROMOp implements CDROMAPI interface
type CDROMOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewCDROMOp creates new CDROMOp instance
func NewCDROMOp(client APICaller) CDROMAPI {
	return &CDROMOp{
		Client:     client,
		PathSuffix: "api/cloud/1.1",
		PathName:   "cdrom",
	}
}

// Find is API call
func (o *CDROMOp) Find(ctx context.Context, zone string, conditions *FindCondition) ([]*CDROM, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if conditions == nil {
			conditions = &FindCondition{}
		}
		if body == nil {
			body = &CDROMFindRequestEnvelope{}
		}
		v := body.(*CDROMFindRequestEnvelope)
		if err := mapconv.ConvertTo(conditions, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &CDROMFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	var payload0 []*CDROM
	for _, v := range nakedResponse.CDROMs {
		payload := &CDROM{}
		if err := payload.convertFrom(v); err != nil {
			return nil, err
		}
		payload0 = append(payload0, payload)
	}
	return payload0, nil
}

// Create is API call
func (o *CDROMOp) Create(ctx context.Context, zone string, param *CDROMCreateRequest) (*CDROM, *FTPServer, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &CDROMCreateRequest{}
		}
		if body == nil {
			body = &CDROMCreateRequestEnvelope{}
		}
		v := body.(*CDROMCreateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, nil, err
		}
		v.CDROM = n
		body = v
	}

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, nil, err
	}

	nakedResponse := &CDROMCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, nil, err
	}

	payload0 := &CDROM{}
	if err := payload0.convertFrom(nakedResponse.CDROM); err != nil {
		return nil, nil, err
	}
	payload1 := &FTPServer{}
	if err := payload1.convertFrom(nakedResponse.FTPServer); err != nil {
		return nil, nil, err
	}
	return payload0, payload1, nil
}

// Read is API call
func (o *CDROMOp) Read(ctx context.Context, zone string, id types.ID) (*CDROM, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &CDROMReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &CDROM{}
	if err := payload0.convertFrom(nakedResponse.CDROM); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Update is API call
func (o *CDROMOp) Update(ctx context.Context, zone string, id types.ID, param *CDROMUpdateRequest) (*CDROM, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &CDROMUpdateRequest{}
		}
		if body == nil {
			body = &CDROMUpdateRequestEnvelope{}
		}
		v := body.(*CDROMUpdateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, err
		}
		v.CDROM = n
		body = v
	}

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &CDROMUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &CDROM{}
	if err := payload0.convertFrom(nakedResponse.CDROM); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Delete is API call
func (o *CDROMOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// OpenFTP is API call
func (o *CDROMOp) OpenFTP(ctx context.Context, zone string, id types.ID, openOption *OpenFTPRequest) (*FTPServer, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/ftp", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"openOption": openOption,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if openOption == nil {
			openOption = &OpenFTPRequest{}
		}
		if body == nil {
			body = &CDROMOpenFTPRequestEnvelope{}
		}
		v := body.(*CDROMOpenFTPRequestEnvelope)
		if err := mapconv.ConvertTo(openOption, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &CDROMOpenFTPResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &FTPServer{}
	if err := payload0.convertFrom(nakedResponse.FTPServer); err != nil {
		return nil, err
	}
	return payload0, nil
}

// CloseFTP is API call
func (o *CDROMOp) CloseFTP(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/ftp", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* DiskOp
*************************************************/

// DiskOp implements DiskAPI interface
type DiskOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewDiskOp creates new DiskOp instance
func NewDiskOp(client APICaller) DiskAPI {
	return &DiskOp{
		Client:     client,
		PathSuffix: "api/cloud/1.1",
		PathName:   "disk",
	}
}

// Find is API call
func (o *DiskOp) Find(ctx context.Context, zone string, conditions *FindCondition) ([]*Disk, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if conditions == nil {
			conditions = &FindCondition{}
		}
		if body == nil {
			body = &DiskFindRequestEnvelope{}
		}
		v := body.(*DiskFindRequestEnvelope)
		if err := mapconv.ConvertTo(conditions, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &DiskFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	var payload0 []*Disk
	for _, v := range nakedResponse.Disks {
		payload := &Disk{}
		if err := payload.convertFrom(v); err != nil {
			return nil, err
		}
		payload0 = append(payload0, payload)
	}
	return payload0, nil
}

// Create is API call
func (o *DiskOp) Create(ctx context.Context, zone string, param *DiskCreateRequest) (*Disk, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &DiskCreateRequest{}
		}
		if body == nil {
			body = &DiskCreateRequestEnvelope{}
		}
		v := body.(*DiskCreateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, err
		}
		v.Disk = n
		body = v
	}

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &DiskCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Disk{}
	if err := payload0.convertFrom(nakedResponse.Disk); err != nil {
		return nil, err
	}
	return payload0, nil
}

// CreateDistantly is API call
func (o *DiskOp) CreateDistantly(ctx context.Context, zone string, createParam *DiskCreateRequest, distantFrom []types.ID) (*Disk, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":     SakuraCloudAPIRoot,
		"pathSuffix":  o.PathSuffix,
		"pathName":    o.PathName,
		"zone":        zone,
		"createParam": createParam,
		"distantFrom": distantFrom,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if createParam == nil {
			createParam = &DiskCreateRequest{}
		}
		if body == nil {
			body = &DiskCreateDistantlyRequestEnvelope{}
		}
		v := body.(*DiskCreateDistantlyRequestEnvelope)
		n, err := createParam.convertTo()
		if err != nil {
			return nil, err
		}
		v.Disk = n
		body = v
	}

	{
		if body == nil {
			body = &DiskCreateDistantlyRequestEnvelope{}
		}
		v := body.(*DiskCreateDistantlyRequestEnvelope)
		v.DistantFrom = distantFrom
		body = v
	}

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &DiskCreateDistantlyResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Disk{}
	if err := payload0.convertFrom(nakedResponse.Disk); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Config is API call
func (o *DiskOp) Config(ctx context.Context, zone string, id types.ID, edit *DiskEditRequest) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/config", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"edit":       edit,
	})
	if err != nil {
		return err
	}

	var body interface{}
	{
		if edit == nil {
			edit = &DiskEditRequest{}
		}
		if body == nil {
			body = &DiskConfigRequestEnvelope{}
		}
		v := body.(*DiskConfigRequestEnvelope)
		if err := mapconv.ConvertTo(edit, v); err != nil {
			return err
		}
		body = v
	}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// CreateWithConfig is API call
func (o *DiskOp) CreateWithConfig(ctx context.Context, zone string, createParam *DiskCreateRequest, editParam *DiskEditRequest, bootAtAvailable bool) (*Disk, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":         SakuraCloudAPIRoot,
		"pathSuffix":      o.PathSuffix,
		"pathName":        o.PathName,
		"zone":            zone,
		"createParam":     createParam,
		"editParam":       editParam,
		"bootAtAvailable": bootAtAvailable,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if createParam == nil {
			createParam = &DiskCreateRequest{}
		}
		if body == nil {
			body = &DiskCreateWithConfigRequestEnvelope{}
		}
		v := body.(*DiskCreateWithConfigRequestEnvelope)
		n, err := createParam.convertTo()
		if err != nil {
			return nil, err
		}
		v.Disk = n
		body = v
	}

	{
		if editParam == nil {
			editParam = &DiskEditRequest{}
		}
		if body == nil {
			body = &DiskCreateWithConfigRequestEnvelope{}
		}
		v := body.(*DiskCreateWithConfigRequestEnvelope)
		n, err := editParam.convertTo()
		if err != nil {
			return nil, err
		}
		v.Config = n
		body = v
	}

	{
		if body == nil {
			body = &DiskCreateWithConfigRequestEnvelope{}
		}
		v := body.(*DiskCreateWithConfigRequestEnvelope)
		v.BootAtAvailable = bootAtAvailable
		body = v
	}

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &DiskCreateWithConfigResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Disk{}
	if err := payload0.convertFrom(nakedResponse.Disk); err != nil {
		return nil, err
	}
	return payload0, nil
}

// CreateWithConfigDistantly is API call
func (o *DiskOp) CreateWithConfigDistantly(ctx context.Context, zone string, createParam *DiskCreateRequest, editParam *DiskEditRequest, bootAtAvailable bool, distantFrom []types.ID) (*Disk, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":         SakuraCloudAPIRoot,
		"pathSuffix":      o.PathSuffix,
		"pathName":        o.PathName,
		"zone":            zone,
		"createParam":     createParam,
		"editParam":       editParam,
		"bootAtAvailable": bootAtAvailable,
		"distantFrom":     distantFrom,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if createParam == nil {
			createParam = &DiskCreateRequest{}
		}
		if body == nil {
			body = &DiskCreateWithConfigDistantlyRequestEnvelope{}
		}
		v := body.(*DiskCreateWithConfigDistantlyRequestEnvelope)
		n, err := createParam.convertTo()
		if err != nil {
			return nil, err
		}
		v.Disk = n
		body = v
	}

	{
		if editParam == nil {
			editParam = &DiskEditRequest{}
		}
		if body == nil {
			body = &DiskCreateWithConfigDistantlyRequestEnvelope{}
		}
		v := body.(*DiskCreateWithConfigDistantlyRequestEnvelope)
		n, err := editParam.convertTo()
		if err != nil {
			return nil, err
		}
		v.Config = n
		body = v
	}

	{
		if body == nil {
			body = &DiskCreateWithConfigDistantlyRequestEnvelope{}
		}
		v := body.(*DiskCreateWithConfigDistantlyRequestEnvelope)
		v.BootAtAvailable = bootAtAvailable
		body = v
	}

	{
		if body == nil {
			body = &DiskCreateWithConfigDistantlyRequestEnvelope{}
		}
		v := body.(*DiskCreateWithConfigDistantlyRequestEnvelope)
		v.DistantFrom = distantFrom
		body = v
	}

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &DiskCreateWithConfigDistantlyResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Disk{}
	if err := payload0.convertFrom(nakedResponse.Disk); err != nil {
		return nil, err
	}
	return payload0, nil
}

// ToBlank is API call
func (o *DiskOp) ToBlank(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/blank", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ResizePartition is API call
func (o *DiskOp) ResizePartition(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/resize-partition", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ConnectToServer is API call
func (o *DiskOp) ConnectToServer(ctx context.Context, zone string, id types.ID, serverID types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/server/{{.serverID}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"serverID":   serverID,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// DisconnectFromServer is API call
func (o *DiskOp) DisconnectFromServer(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/server", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Install is API call
func (o *DiskOp) Install(ctx context.Context, zone string, id types.ID, installParam *DiskInstallRequest, distantFrom []types.ID) (*Disk, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/install", map[string]interface{}{
		"rootURL":      SakuraCloudAPIRoot,
		"pathSuffix":   o.PathSuffix,
		"pathName":     o.PathName,
		"zone":         zone,
		"id":           id,
		"installParam": installParam,
		"distantFrom":  distantFrom,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if installParam == nil {
			installParam = &DiskInstallRequest{}
		}
		if body == nil {
			body = &DiskInstallRequestEnvelope{}
		}
		v := body.(*DiskInstallRequestEnvelope)
		n, err := installParam.convertTo()
		if err != nil {
			return nil, err
		}
		v.Disk = n
		body = v
	}

	{
		if body == nil {
			body = &DiskInstallRequestEnvelope{}
		}
		v := body.(*DiskInstallRequestEnvelope)
		v.DistantFrom = distantFrom
		body = v
	}

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &DiskInstallResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Disk{}
	if err := payload0.convertFrom(nakedResponse.Disk); err != nil {
		return nil, err
	}
	return payload0, nil
}

// InstallDistantFrom is API call
func (o *DiskOp) InstallDistantFrom(ctx context.Context, zone string, id types.ID, installParam *DiskInstallRequest) (*Disk, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/install", map[string]interface{}{
		"rootURL":      SakuraCloudAPIRoot,
		"pathSuffix":   o.PathSuffix,
		"pathName":     o.PathName,
		"zone":         zone,
		"id":           id,
		"installParam": installParam,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if installParam == nil {
			installParam = &DiskInstallRequest{}
		}
		if body == nil {
			body = &DiskInstallDistantFromRequestEnvelope{}
		}
		v := body.(*DiskInstallDistantFromRequestEnvelope)
		n, err := installParam.convertTo()
		if err != nil {
			return nil, err
		}
		v.Disk = n
		body = v
	}

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &DiskInstallDistantFromResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Disk{}
	if err := payload0.convertFrom(nakedResponse.Disk); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Read is API call
func (o *DiskOp) Read(ctx context.Context, zone string, id types.ID) (*Disk, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &DiskReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Disk{}
	if err := payload0.convertFrom(nakedResponse.Disk); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Update is API call
func (o *DiskOp) Update(ctx context.Context, zone string, id types.ID, param *DiskUpdateRequest) (*Disk, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &DiskUpdateRequest{}
		}
		if body == nil {
			body = &DiskUpdateRequestEnvelope{}
		}
		v := body.(*DiskUpdateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, err
		}
		v.Disk = n
		body = v
	}

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &DiskUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Disk{}
	if err := payload0.convertFrom(nakedResponse.Disk); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Delete is API call
func (o *DiskOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Monitor is API call
func (o *DiskOp) Monitor(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*DiskActivity, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if condition == nil {
			condition = &MonitorCondition{}
		}
		if body == nil {
			body = &DiskMonitorRequestEnvelope{}
		}
		v := body.(*DiskMonitorRequestEnvelope)
		if err := mapconv.ConvertTo(condition, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &DiskMonitorResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &DiskActivity{}
	if err := payload0.convertFrom(nakedResponse.Data); err != nil {
		return nil, err
	}
	return payload0, nil
}

/*************************************************
* GSLBOp
*************************************************/

// GSLBOp implements GSLBAPI interface
type GSLBOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewGSLBOp creates new GSLBOp instance
func NewGSLBOp(client APICaller) GSLBAPI {
	return &GSLBOp{
		Client:     client,
		PathSuffix: "api/cloud/1.1",
		PathName:   "commonserviceitem",
	}
}

// Find is API call
func (o *GSLBOp) Find(ctx context.Context, zone string, conditions *FindCondition) ([]*GSLB, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if conditions == nil {
			conditions = &FindCondition{}
		}
		if body == nil {
			body = &GSLBFindRequestEnvelope{}
		}
		v := body.(*GSLBFindRequestEnvelope)
		if err := mapconv.ConvertTo(conditions, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &GSLBFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	var payload0 []*GSLB
	for _, v := range nakedResponse.CommonServiceItems {
		payload := &GSLB{}
		if err := payload.convertFrom(v); err != nil {
			return nil, err
		}
		payload0 = append(payload0, payload)
	}
	return payload0, nil
}

// Create is API call
func (o *GSLBOp) Create(ctx context.Context, zone string, param *GSLBCreateRequest) (*GSLB, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &GSLBCreateRequest{}
		}
		if body == nil {
			body = &GSLBCreateRequestEnvelope{}
		}
		v := body.(*GSLBCreateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, err
		}
		v.CommonServiceItem = n
		body = v
	}

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &GSLBCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &GSLB{}
	if err := payload0.convertFrom(nakedResponse.CommonServiceItem); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Read is API call
func (o *GSLBOp) Read(ctx context.Context, zone string, id types.ID) (*GSLB, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &GSLBReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &GSLB{}
	if err := payload0.convertFrom(nakedResponse.CommonServiceItem); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Update is API call
func (o *GSLBOp) Update(ctx context.Context, zone string, id types.ID, param *GSLBUpdateRequest) (*GSLB, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &GSLBUpdateRequest{}
		}
		if body == nil {
			body = &GSLBUpdateRequestEnvelope{}
		}
		v := body.(*GSLBUpdateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, err
		}
		v.CommonServiceItem = n
		body = v
	}

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &GSLBUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &GSLB{}
	if err := payload0.convertFrom(nakedResponse.CommonServiceItem); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Delete is API call
func (o *GSLBOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* InterfaceOp
*************************************************/

// InterfaceOp implements InterfaceAPI interface
type InterfaceOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewInterfaceOp creates new InterfaceOp instance
func NewInterfaceOp(client APICaller) InterfaceAPI {
	return &InterfaceOp{
		Client:     client,
		PathSuffix: "api/cloud/1.1",
		PathName:   "interface",
	}
}

// Find is API call
func (o *InterfaceOp) Find(ctx context.Context, zone string, conditions *FindCondition) ([]*Interface, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if conditions == nil {
			conditions = &FindCondition{}
		}
		if body == nil {
			body = &InterfaceFindRequestEnvelope{}
		}
		v := body.(*InterfaceFindRequestEnvelope)
		if err := mapconv.ConvertTo(conditions, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &InterfaceFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	var payload0 []*Interface
	for _, v := range nakedResponse.Interfaces {
		payload := &Interface{}
		if err := payload.convertFrom(v); err != nil {
			return nil, err
		}
		payload0 = append(payload0, payload)
	}
	return payload0, nil
}

// Create is API call
func (o *InterfaceOp) Create(ctx context.Context, zone string, param *InterfaceCreateRequest) (*Interface, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &InterfaceCreateRequest{}
		}
		if body == nil {
			body = &InterfaceCreateRequestEnvelope{}
		}
		v := body.(*InterfaceCreateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, err
		}
		v.Interface = n
		body = v
	}

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &InterfaceCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Interface{}
	if err := payload0.convertFrom(nakedResponse.Interface); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Read is API call
func (o *InterfaceOp) Read(ctx context.Context, zone string, id types.ID) (*Interface, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &InterfaceReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Interface{}
	if err := payload0.convertFrom(nakedResponse.Interface); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Update is API call
func (o *InterfaceOp) Update(ctx context.Context, zone string, id types.ID, param *InterfaceUpdateRequest) (*Interface, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &InterfaceUpdateRequest{}
		}
		if body == nil {
			body = &InterfaceUpdateRequestEnvelope{}
		}
		v := body.(*InterfaceUpdateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, err
		}
		v.Interface = n
		body = v
	}

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &InterfaceUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Interface{}
	if err := payload0.convertFrom(nakedResponse.Interface); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Delete is API call
func (o *InterfaceOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Monitor is API call
func (o *InterfaceOp) Monitor(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*InterfaceActivity, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if condition == nil {
			condition = &MonitorCondition{}
		}
		if body == nil {
			body = &InterfaceMonitorRequestEnvelope{}
		}
		v := body.(*InterfaceMonitorRequestEnvelope)
		if err := mapconv.ConvertTo(condition, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &InterfaceMonitorResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &InterfaceActivity{}
	if err := payload0.convertFrom(nakedResponse.Data); err != nil {
		return nil, err
	}
	return payload0, nil
}

// ConnectToSharedSegment is API call
func (o *InterfaceOp) ConnectToSharedSegment(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/switch/shared", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ConnectToSwitch is API call
func (o *InterfaceOp) ConnectToSwitch(ctx context.Context, zone string, id types.ID, switchID types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/switch/{{.switchID}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"switchID":   switchID,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// DisconnectFromSwitch is API call
func (o *InterfaceOp) DisconnectFromSwitch(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/switch", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ConnectToPacketFilter is API call
func (o *InterfaceOp) ConnectToPacketFilter(ctx context.Context, zone string, id types.ID, packetFilterID types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/packetfilter/{{.packetFilterID}}", map[string]interface{}{
		"rootURL":        SakuraCloudAPIRoot,
		"pathSuffix":     o.PathSuffix,
		"pathName":       o.PathName,
		"zone":           zone,
		"id":             id,
		"packetFilterID": packetFilterID,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// DisconnectFromPacketFilter is API call
func (o *InterfaceOp) DisconnectFromPacketFilter(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/packetfilter", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* LoadBalancerOp
*************************************************/

// LoadBalancerOp implements LoadBalancerAPI interface
type LoadBalancerOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewLoadBalancerOp creates new LoadBalancerOp instance
func NewLoadBalancerOp(client APICaller) LoadBalancerAPI {
	return &LoadBalancerOp{
		Client:     client,
		PathSuffix: "api/cloud/1.1",
		PathName:   "appliance",
	}
}

// Find is API call
func (o *LoadBalancerOp) Find(ctx context.Context, zone string, conditions *FindCondition) ([]*LoadBalancer, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if conditions == nil {
			conditions = &FindCondition{}
		}
		if body == nil {
			body = &LoadBalancerFindRequestEnvelope{}
		}
		v := body.(*LoadBalancerFindRequestEnvelope)
		if err := mapconv.ConvertTo(conditions, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &LoadBalancerFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	var payload0 []*LoadBalancer
	for _, v := range nakedResponse.Appliances {
		payload := &LoadBalancer{}
		if err := payload.convertFrom(v); err != nil {
			return nil, err
		}
		payload0 = append(payload0, payload)
	}
	return payload0, nil
}

// Create is API call
func (o *LoadBalancerOp) Create(ctx context.Context, zone string, param *LoadBalancerCreateRequest) (*LoadBalancer, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &LoadBalancerCreateRequest{}
		}
		if body == nil {
			body = &LoadBalancerCreateRequestEnvelope{}
		}
		v := body.(*LoadBalancerCreateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, err
		}
		v.Appliance = n
		body = v
	}

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &LoadBalancerCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &LoadBalancer{}
	if err := payload0.convertFrom(nakedResponse.Appliance); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Read is API call
func (o *LoadBalancerOp) Read(ctx context.Context, zone string, id types.ID) (*LoadBalancer, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &LoadBalancerReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &LoadBalancer{}
	if err := payload0.convertFrom(nakedResponse.Appliance); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Update is API call
func (o *LoadBalancerOp) Update(ctx context.Context, zone string, id types.ID, param *LoadBalancerUpdateRequest) (*LoadBalancer, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &LoadBalancerUpdateRequest{}
		}
		if body == nil {
			body = &LoadBalancerUpdateRequestEnvelope{}
		}
		v := body.(*LoadBalancerUpdateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, err
		}
		v.Appliance = n
		body = v
	}

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &LoadBalancerUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &LoadBalancer{}
	if err := payload0.convertFrom(nakedResponse.Appliance); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Delete is API call
func (o *LoadBalancerOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Config is API call
func (o *LoadBalancerOp) Config(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/config", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Boot is API call
func (o *LoadBalancerOp) Boot(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Shutdown is API call
func (o *LoadBalancerOp) Shutdown(ctx context.Context, zone string, id types.ID, shutdownOption *ShutdownOption) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":        SakuraCloudAPIRoot,
		"pathSuffix":     o.PathSuffix,
		"pathName":       o.PathName,
		"zone":           zone,
		"id":             id,
		"shutdownOption": shutdownOption,
	})
	if err != nil {
		return err
	}

	var body interface{}
	{
		if shutdownOption == nil {
			shutdownOption = &ShutdownOption{}
		}
		if body == nil {
			body = &LoadBalancerShutdownRequestEnvelope{}
		}
		v := body.(*LoadBalancerShutdownRequestEnvelope)
		if err := mapconv.ConvertTo(shutdownOption, v); err != nil {
			return err
		}
		body = v
	}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Reset is API call
func (o *LoadBalancerOp) Reset(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/reset", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// MonitorInterface is API call
func (o *LoadBalancerOp) MonitorInterface(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*InterfaceActivity, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/interface/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if condition == nil {
			condition = &MonitorCondition{}
		}
		if body == nil {
			body = &LoadBalancerMonitorInterfaceRequestEnvelope{}
		}
		v := body.(*LoadBalancerMonitorInterfaceRequestEnvelope)
		if err := mapconv.ConvertTo(condition, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &LoadBalancerMonitorInterfaceResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &InterfaceActivity{}
	if err := payload0.convertFrom(nakedResponse.Data); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Status is API call
func (o *LoadBalancerOp) Status(ctx context.Context, zone string, id types.ID) ([]*LoadBalancerStatus, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/status", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &LoadBalancerStatusResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	var payload0 []*LoadBalancerStatus
	for _, v := range nakedResponse.LoadBalancer {
		payload := &LoadBalancerStatus{}
		if err := payload.convertFrom(v); err != nil {
			return nil, err
		}
		payload0 = append(payload0, payload)
	}
	return payload0, nil
}

/*************************************************
* NFSOp
*************************************************/

// NFSOp implements NFSAPI interface
type NFSOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewNFSOp creates new NFSOp instance
func NewNFSOp(client APICaller) NFSAPI {
	return &NFSOp{
		Client:     client,
		PathSuffix: "api/cloud/1.1",
		PathName:   "appliance",
	}
}

// Find is API call
func (o *NFSOp) Find(ctx context.Context, zone string, conditions *FindCondition) ([]*NFS, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if conditions == nil {
			conditions = &FindCondition{}
		}
		if body == nil {
			body = &NFSFindRequestEnvelope{}
		}
		v := body.(*NFSFindRequestEnvelope)
		if err := mapconv.ConvertTo(conditions, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &NFSFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	var payload0 []*NFS
	for _, v := range nakedResponse.Appliances {
		payload := &NFS{}
		if err := payload.convertFrom(v); err != nil {
			return nil, err
		}
		payload0 = append(payload0, payload)
	}
	return payload0, nil
}

// Create is API call
func (o *NFSOp) Create(ctx context.Context, zone string, param *NFSCreateRequest) (*NFS, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &NFSCreateRequest{}
		}
		if body == nil {
			body = &NFSCreateRequestEnvelope{}
		}
		v := body.(*NFSCreateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, err
		}
		v.Appliance = n
		body = v
	}

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &NFSCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &NFS{}
	if err := payload0.convertFrom(nakedResponse.Appliance); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Read is API call
func (o *NFSOp) Read(ctx context.Context, zone string, id types.ID) (*NFS, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &NFSReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &NFS{}
	if err := payload0.convertFrom(nakedResponse.Appliance); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Update is API call
func (o *NFSOp) Update(ctx context.Context, zone string, id types.ID, param *NFSUpdateRequest) (*NFS, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &NFSUpdateRequest{}
		}
		if body == nil {
			body = &NFSUpdateRequestEnvelope{}
		}
		v := body.(*NFSUpdateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, err
		}
		v.Appliance = n
		body = v
	}

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &NFSUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &NFS{}
	if err := payload0.convertFrom(nakedResponse.Appliance); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Delete is API call
func (o *NFSOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Boot is API call
func (o *NFSOp) Boot(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Shutdown is API call
func (o *NFSOp) Shutdown(ctx context.Context, zone string, id types.ID, shutdownOption *ShutdownOption) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":        SakuraCloudAPIRoot,
		"pathSuffix":     o.PathSuffix,
		"pathName":       o.PathName,
		"zone":           zone,
		"id":             id,
		"shutdownOption": shutdownOption,
	})
	if err != nil {
		return err
	}

	var body interface{}
	{
		if shutdownOption == nil {
			shutdownOption = &ShutdownOption{}
		}
		if body == nil {
			body = &NFSShutdownRequestEnvelope{}
		}
		v := body.(*NFSShutdownRequestEnvelope)
		if err := mapconv.ConvertTo(shutdownOption, v); err != nil {
			return err
		}
		body = v
	}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Reset is API call
func (o *NFSOp) Reset(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/reset", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// MonitorFreeDiskSize is API call
func (o *NFSOp) MonitorFreeDiskSize(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*FreeDiskSizeActivity, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/database/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if condition == nil {
			condition = &MonitorCondition{}
		}
		if body == nil {
			body = &NFSMonitorFreeDiskSizeRequestEnvelope{}
		}
		v := body.(*NFSMonitorFreeDiskSizeRequestEnvelope)
		if err := mapconv.ConvertTo(condition, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &NFSMonitorFreeDiskSizeResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &FreeDiskSizeActivity{}
	if err := payload0.convertFrom(nakedResponse.Data); err != nil {
		return nil, err
	}
	return payload0, nil
}

// MonitorInterface is API call
func (o *NFSOp) MonitorInterface(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*InterfaceActivity, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/interface/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if condition == nil {
			condition = &MonitorCondition{}
		}
		if body == nil {
			body = &NFSMonitorInterfaceRequestEnvelope{}
		}
		v := body.(*NFSMonitorInterfaceRequestEnvelope)
		if err := mapconv.ConvertTo(condition, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &NFSMonitorInterfaceResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &InterfaceActivity{}
	if err := payload0.convertFrom(nakedResponse.Data); err != nil {
		return nil, err
	}
	return payload0, nil
}

/*************************************************
* NoteOp
*************************************************/

// NoteOp implements NoteAPI interface
type NoteOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewNoteOp creates new NoteOp instance
func NewNoteOp(client APICaller) NoteAPI {
	return &NoteOp{
		Client:     client,
		PathSuffix: "api/cloud/1.1",
		PathName:   "note",
	}
}

// Find is API call
func (o *NoteOp) Find(ctx context.Context, zone string, conditions *FindCondition) ([]*Note, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if conditions == nil {
			conditions = &FindCondition{}
		}
		if body == nil {
			body = &NoteFindRequestEnvelope{}
		}
		v := body.(*NoteFindRequestEnvelope)
		if err := mapconv.ConvertTo(conditions, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &NoteFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	var payload0 []*Note
	for _, v := range nakedResponse.Notes {
		payload := &Note{}
		if err := payload.convertFrom(v); err != nil {
			return nil, err
		}
		payload0 = append(payload0, payload)
	}
	return payload0, nil
}

// Create is API call
func (o *NoteOp) Create(ctx context.Context, zone string, param *NoteCreateRequest) (*Note, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &NoteCreateRequest{}
		}
		if body == nil {
			body = &NoteCreateRequestEnvelope{}
		}
		v := body.(*NoteCreateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, err
		}
		v.Note = n
		body = v
	}

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &NoteCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Note{}
	if err := payload0.convertFrom(nakedResponse.Note); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Read is API call
func (o *NoteOp) Read(ctx context.Context, zone string, id types.ID) (*Note, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &NoteReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Note{}
	if err := payload0.convertFrom(nakedResponse.Note); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Update is API call
func (o *NoteOp) Update(ctx context.Context, zone string, id types.ID, param *NoteUpdateRequest) (*Note, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &NoteUpdateRequest{}
		}
		if body == nil {
			body = &NoteUpdateRequestEnvelope{}
		}
		v := body.(*NoteUpdateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, err
		}
		v.Note = n
		body = v
	}

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &NoteUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Note{}
	if err := payload0.convertFrom(nakedResponse.Note); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Delete is API call
func (o *NoteOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* ServerOp
*************************************************/

// ServerOp implements ServerAPI interface
type ServerOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewServerOp creates new ServerOp instance
func NewServerOp(client APICaller) ServerAPI {
	return &ServerOp{
		Client:     client,
		PathSuffix: "api/cloud/1.1",
		PathName:   "server",
	}
}

// Find is API call
func (o *ServerOp) Find(ctx context.Context, zone string, conditions *FindCondition) ([]*Server, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if conditions == nil {
			conditions = &FindCondition{}
		}
		if body == nil {
			body = &ServerFindRequestEnvelope{}
		}
		v := body.(*ServerFindRequestEnvelope)
		if err := mapconv.ConvertTo(conditions, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &ServerFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	var payload0 []*Server
	for _, v := range nakedResponse.Servers {
		payload := &Server{}
		if err := payload.convertFrom(v); err != nil {
			return nil, err
		}
		payload0 = append(payload0, payload)
	}
	return payload0, nil
}

// Create is API call
func (o *ServerOp) Create(ctx context.Context, zone string, param *ServerCreateRequest) (*Server, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &ServerCreateRequest{}
		}
		if body == nil {
			body = &ServerCreateRequestEnvelope{}
		}
		v := body.(*ServerCreateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, err
		}
		v.Server = n
		body = v
	}

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &ServerCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Server{}
	if err := payload0.convertFrom(nakedResponse.Server); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Read is API call
func (o *ServerOp) Read(ctx context.Context, zone string, id types.ID) (*Server, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &ServerReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Server{}
	if err := payload0.convertFrom(nakedResponse.Server); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Update is API call
func (o *ServerOp) Update(ctx context.Context, zone string, id types.ID, param *ServerUpdateRequest) (*Server, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &ServerUpdateRequest{}
		}
		if body == nil {
			body = &ServerUpdateRequestEnvelope{}
		}
		v := body.(*ServerUpdateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, err
		}
		v.Server = n
		body = v
	}

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &ServerUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Server{}
	if err := payload0.convertFrom(nakedResponse.Server); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Delete is API call
func (o *ServerOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ChangePlan is API call
func (o *ServerOp) ChangePlan(ctx context.Context, zone string, id types.ID, plan *ServerChangePlanRequest) (*Server, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/plan", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"plan":       plan,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if plan == nil {
			plan = &ServerChangePlanRequest{}
		}
		if body == nil {
			body = &ServerChangePlanRequestEnvelope{}
		}
		v := body.(*ServerChangePlanRequestEnvelope)
		if err := mapconv.ConvertTo(plan, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &ServerChangePlanResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Server{}
	if err := payload0.convertFrom(nakedResponse.Server); err != nil {
		return nil, err
	}
	return payload0, nil
}

// InsertCDROM is API call
func (o *ServerOp) InsertCDROM(ctx context.Context, zone string, id types.ID, insertParam *InsertCDROMRequest) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/cdrom", map[string]interface{}{
		"rootURL":     SakuraCloudAPIRoot,
		"pathSuffix":  o.PathSuffix,
		"pathName":    o.PathName,
		"zone":        zone,
		"id":          id,
		"insertParam": insertParam,
	})
	if err != nil {
		return err
	}

	var body interface{}

	{
		if insertParam == nil {
			insertParam = &InsertCDROMRequest{}
		}
		if body == nil {
			body = &ServerInsertCDROMRequestEnvelope{}
		}
		v := body.(*ServerInsertCDROMRequestEnvelope)
		n, err := insertParam.convertTo()
		if err != nil {
			return err
		}
		v.CDROM = n
		body = v
	}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// EjectCDROM is API call
func (o *ServerOp) EjectCDROM(ctx context.Context, zone string, id types.ID, insertParam *EjectCDROMRequest) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/cdrom", map[string]interface{}{
		"rootURL":     SakuraCloudAPIRoot,
		"pathSuffix":  o.PathSuffix,
		"pathName":    o.PathName,
		"zone":        zone,
		"id":          id,
		"insertParam": insertParam,
	})
	if err != nil {
		return err
	}

	var body interface{}

	{
		if insertParam == nil {
			insertParam = &EjectCDROMRequest{}
		}
		if body == nil {
			body = &ServerEjectCDROMRequestEnvelope{}
		}
		v := body.(*ServerEjectCDROMRequestEnvelope)
		n, err := insertParam.convertTo()
		if err != nil {
			return err
		}
		v.CDROM = n
		body = v
	}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Boot is API call
func (o *ServerOp) Boot(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Shutdown is API call
func (o *ServerOp) Shutdown(ctx context.Context, zone string, id types.ID, shutdownOption *ShutdownOption) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/power", map[string]interface{}{
		"rootURL":        SakuraCloudAPIRoot,
		"pathSuffix":     o.PathSuffix,
		"pathName":       o.PathName,
		"zone":           zone,
		"id":             id,
		"shutdownOption": shutdownOption,
	})
	if err != nil {
		return err
	}

	var body interface{}
	{
		if shutdownOption == nil {
			shutdownOption = &ShutdownOption{}
		}
		if body == nil {
			body = &ServerShutdownRequestEnvelope{}
		}
		v := body.(*ServerShutdownRequestEnvelope)
		if err := mapconv.ConvertTo(shutdownOption, v); err != nil {
			return err
		}
		body = v
	}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Reset is API call
func (o *ServerOp) Reset(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/reset", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// Monitor is API call
func (o *ServerOp) Monitor(ctx context.Context, zone string, id types.ID, condition *MonitorCondition) (*CPUTimeActivity, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/monitor", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"condition":  condition,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if condition == nil {
			condition = &MonitorCondition{}
		}
		if body == nil {
			body = &ServerMonitorRequestEnvelope{}
		}
		v := body.(*ServerMonitorRequestEnvelope)
		if err := mapconv.ConvertTo(condition, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &ServerMonitorResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &CPUTimeActivity{}
	if err := payload0.convertFrom(nakedResponse.Data); err != nil {
		return nil, err
	}
	return payload0, nil
}

/*************************************************
* SwitchOp
*************************************************/

// SwitchOp implements SwitchAPI interface
type SwitchOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewSwitchOp creates new SwitchOp instance
func NewSwitchOp(client APICaller) SwitchAPI {
	return &SwitchOp{
		Client:     client,
		PathSuffix: "api/cloud/1.1",
		PathName:   "switch",
	}
}

// Find is API call
func (o *SwitchOp) Find(ctx context.Context, zone string, conditions *FindCondition) ([]*Switch, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if conditions == nil {
			conditions = &FindCondition{}
		}
		if body == nil {
			body = &SwitchFindRequestEnvelope{}
		}
		v := body.(*SwitchFindRequestEnvelope)
		if err := mapconv.ConvertTo(conditions, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &SwitchFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	var payload0 []*Switch
	for _, v := range nakedResponse.Switches {
		payload := &Switch{}
		if err := payload.convertFrom(v); err != nil {
			return nil, err
		}
		payload0 = append(payload0, payload)
	}
	return payload0, nil
}

// Create is API call
func (o *SwitchOp) Create(ctx context.Context, zone string, param *SwitchCreateRequest) (*Switch, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &SwitchCreateRequest{}
		}
		if body == nil {
			body = &SwitchCreateRequestEnvelope{}
		}
		v := body.(*SwitchCreateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, err
		}
		v.Switch = n
		body = v
	}

	data, err := o.Client.Do(ctx, "POST", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &SwitchCreateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Switch{}
	if err := payload0.convertFrom(nakedResponse.Switch); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Read is API call
func (o *SwitchOp) Read(ctx context.Context, zone string, id types.ID) (*Switch, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &SwitchReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Switch{}
	if err := payload0.convertFrom(nakedResponse.Switch); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Update is API call
func (o *SwitchOp) Update(ctx context.Context, zone string, id types.ID, param *SwitchUpdateRequest) (*Switch, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"param":      param,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	{
		if param == nil {
			param = &SwitchUpdateRequest{}
		}
		if body == nil {
			body = &SwitchUpdateRequestEnvelope{}
		}
		v := body.(*SwitchUpdateRequestEnvelope)
		n, err := param.convertTo()
		if err != nil {
			return nil, err
		}
		v.Switch = n
		body = v
	}

	data, err := o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &SwitchUpdateResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Switch{}
	if err := payload0.convertFrom(nakedResponse.Switch); err != nil {
		return nil, err
	}
	return payload0, nil
}

// Delete is API call
func (o *SwitchOp) Delete(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

// ConnectToBridge is API call
func (o *SwitchOp) ConnectToBridge(ctx context.Context, zone string, id types.ID, bridgeID types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/bridge/{{.bridgeID}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
		"bridgeID":   bridgeID,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "PUT", url, body)
	if err != nil {
		return err
	}

	return nil
}

// DisconnectFromBridge is API call
func (o *SwitchOp) DisconnectFromBridge(ctx context.Context, zone string, id types.ID) error {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}/to/bridge", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return err
	}

	var body interface{}

	_, err = o.Client.Do(ctx, "DELETE", url, body)
	if err != nil {
		return err
	}

	return nil
}

/*************************************************
* ZoneOp
*************************************************/

// ZoneOp implements ZoneAPI interface
type ZoneOp struct {
	// Client APICaller
	Client APICaller
	// PathSuffix is used when building URL
	PathSuffix string
	// PathName is used when building URL
	PathName string
}

// NewZoneOp creates new ZoneOp instance
func NewZoneOp(client APICaller) ZoneAPI {
	return &ZoneOp{
		Client:     client,
		PathSuffix: "api/cloud/1.1",
		PathName:   "zone",
	}
}

// Find is API call
func (o *ZoneOp) Find(ctx context.Context, zone string, conditions *FindCondition) ([]*Zone, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"conditions": conditions,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}
	{
		if conditions == nil {
			conditions = &FindCondition{}
		}
		if body == nil {
			body = &ZoneFindRequestEnvelope{}
		}
		v := body.(*ZoneFindRequestEnvelope)
		if err := mapconv.ConvertTo(conditions, v); err != nil {
			return nil, err
		}
		body = v
	}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &ZoneFindResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	var payload0 []*Zone
	for _, v := range nakedResponse.Zones {
		payload := &Zone{}
		if err := payload.convertFrom(v); err != nil {
			return nil, err
		}
		payload0 = append(payload0, payload)
	}
	return payload0, nil
}

// Read is API call
func (o *ZoneOp) Read(ctx context.Context, zone string, id types.ID) (*Zone, error) {
	url, err := buildURL("{{.rootURL}}/{{.zone}}/{{.pathSuffix}}/{{.pathName}}/{{.id}}", map[string]interface{}{
		"rootURL":    SakuraCloudAPIRoot,
		"pathSuffix": o.PathSuffix,
		"pathName":   o.PathName,
		"zone":       zone,
		"id":         id,
	})
	if err != nil {
		return nil, err
	}

	var body interface{}

	data, err := o.Client.Do(ctx, "GET", url, body)
	if err != nil {
		return nil, err
	}

	nakedResponse := &ZoneReadResponseEnvelope{}
	if err := json.Unmarshal(data, nakedResponse); err != nil {
		return nil, err
	}

	payload0 := &Zone{}
	if err := payload0.convertFrom(nakedResponse.Zone); err != nil {
		return nil, err
	}
	return payload0, nil
}
